<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Snake ‚Äî Samuel Barnhurst</title>
  <style>
    :root{
      --bg:#0d1117; --card:#161b22; --ink:#e6edf3; --muted:#30363d; --accent:#00ffff; --accent-2:#00b3b3;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;
      background:var(--bg); color:var(--ink);
      min-height:100vh; display:flex; flex-direction:column; align-items:center; gap:.75rem; padding:1rem;
    }
    h1{margin:.25rem 0; color:var(--accent); font-weight:800; letter-spacing:.5px}
    .row{display:flex; gap:.75rem; flex-wrap:wrap; align-items:center; justify-content:center}
    .card{background:var(--card); border:1px solid var(--muted); border-radius:12px; padding:.6rem .9rem}
    select, .btn{
      appearance:none; background:var(--card); color:var(--ink);
      border:1px solid var(--muted); border-radius:10px; padding:.6rem .9rem;
      font-weight:600; cursor:pointer; transition:background .2s,color .2s,transform .04s ease-in-out;
    }
    .btn:hover, select:hover{background:#17202a}
    .btn:active{transform:translateY(1px)}
    .btn.primary{border-color:var(--accent-2)}
    .btn.primary:hover{background:var(--accent-2); color:#fff}
    .btn.accent{border-color:var(--accent)}
    .btn.accent:hover{background:var(--accent); color:#001013}
    .hud{
      display:flex; align-items:center; justify-content:center; gap:1.5rem;
      padding:.4rem .9rem; border-radius:10px; border:1px solid var(--muted); background:var(--card)
    }
    .score{font-size:1.25rem; font-weight:800; color:var(--accent)}
    .hi{opacity:.9}
    .canvas-wrap{width:min(560px,100%)}
    canvas{
      width:100%; height:auto;
      background:var(--card); border:2px solid var(--accent); border-radius:12px; display:block; margin:.5rem 0 0;
      touch-action:none;
    }
    /* Overlay (pause & game over) */
    .overlay{
      position:fixed; inset:0; display:none; align-items:center; justify-content:center;
      background:rgba(0,0,0,.55); backdrop-filter:blur(2px); z-index:10;
    }
    .overlay.show{display:flex}
    .modal{
      width:min(520px,92%); background:var(--card); border:1px solid var(--muted); border-radius:14px; padding:1.2rem;
      text-align:center; box-shadow:0 10px 30px rgba(0,0,0,.35);
    }
    .modal h2{margin:.25rem 0 .5rem; color:var(--accent)}
    .modal p{margin:.25rem 0 .9rem; opacity:.9}
    .modal .row{margin-top:.6rem}
    /* Mobile on-screen D-pad */
    .touch-controls{display:none; gap:.5rem; margin-top:.5rem; flex-wrap:wrap; justify-content:center}
    .pad{min-width:86px; padding:.7rem 1rem; text-align:center; user-select:none}
    @media (max-width: 768px){ .touch-controls{display:flex} }
    :focus-visible{outline:2px solid var(--accent); outline-offset:2px}
  </style>
</head>
<body>
  <h1>üêç Snake</h1>

  <div class="row">
    <label class="card" for="speed">Speed:
      <select id="speed" aria-label="Game speed">
        <option value="140">Slow</option>
        <option value="110" selected>Normal</option>
        <option value="80">Fast</option>
        <option value="60">Insane</option>
      </select>
    </label>

    <div class="hud">
      <span>Score <span class="score" id="score">0</span></span>
      <span class="hi">High&nbsp;Score: <strong id="hiScore">0</strong></span>
    </div>

    <div class="row">
      <button class="btn primary" id="restartBtn" aria-label="Restart">üîÅ Restart</button>
      <button class="btn accent" id="pauseBtn" aria-label="Pause or resume">‚è∏Ô∏è Pause</button>
      <button class="btn" id="backBtn" aria-label="Back">‚¨Ö Back</button>
    </div>
  </div>

  <div class="canvas-wrap">
    <!-- Internal res is fixed 400x400; CSS scales responsively -->
    <canvas id="board" width="400" height="400" aria-label="Snake game area"></canvas>
  </div>

  <!-- Mobile D-pad -->
  <div class="touch-controls" aria-hidden="false">
    <button class="btn pad" id="up">‚¨Ü Up</button>
    <div class="row">
      <button class="btn pad" id="left">‚¨Ö Left</button>
      <button class="btn pad" id="right">‚û° Right</button>
    </div>
    <button class="btn pad" id="down">‚¨á Down</button>
  </div>

  <!-- Overlay -->
  <div class="overlay" id="overlay" role="dialog" aria-modal="true" aria-labelledby="ovTitle">
    <div class="modal">
      <h2 id="ovTitle">Game Over</h2>
      <p id="ovText">Score: 0</p>
      <div class="row">
        <button class="btn primary" id="ovRestart">üîÅ Restart</button>
        <button class="btn" id="ovBack">‚¨Ö Back</button>
      </div>
    </div>
  </div>

  <p class="card" style="max-width:560px">
    <strong>Controls:</strong> Arrows to move ¬∑ <kbd>P</kbd> Pause/Resume ¬∑ <kbd>R</kbd> Restart
  </p>

  <script>
    // --- Elements
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const speedSel = document.getElementById('speed');
    const scoreEl = document.getElementById('score');
    const hiScoreEl = document.getElementById('hiScore');
    const restartBtn = document.getElementById('restartBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const backBtn = document.getElementById('backBtn');
    const overlay = document.getElementById('overlay');
    const ovTitle = document.getElementById('ovTitle');
    const ovText = document.getElementById('ovText');
    const ovRestart = document.getElementById('ovRestart');
    const ovBack = document.getElementById('ovBack');

    // D-pad
    const upBtn = document.getElementById('up');
    const downBtn = document.getElementById('down');
    const leftBtn = document.getElementById('left');
    const rightBtn = document.getElementById('right');

    // --- Config
    const GRID = 20; // size of a cell in px
    const COLS = canvas.width / GRID;
    const ROWS = canvas.height / GRID;
    const HI_KEY = 'snakeHighScore';

    // --- State
    let snake, dir, nextDir, food, score, tickMs, accMs, lastTs, running, paused, rafId;

    function initState() {
      snake = [{x: 10*GRID, y: 10*GRID}];            // start center-ish
      dir = {x: GRID, y: 0};                         // moving right
      nextDir = {...dir};
      food = spawnFood();
      score = 0;
      tickMs = Number(speedSel.value);               // step duration in ms
      accMs = 0; lastTs = performance.now();
      running = false; paused = false;
      scoreEl.textContent = '0';
      hiScoreEl.textContent = String(Number(localStorage.getItem(HI_KEY) || 0));
      hideOverlay();
      draw(); // initial frame
    }

    function spawnFood() {
      // Avoid placing food on the snake
      while (true) {
        const fx = Math.floor(Math.random()*COLS) * GRID;
        const fy = Math.floor(Math.random()*ROWS) * GRID;
        if (!snake.some(s => s.x===fx && s.y===fy)) return {x:fx, y:fy};
      }
    }

    function update(dtMs) {
      accMs += dtMs;
      if (accMs < tickMs) return;          // step only when enough time elapsed
      accMs %= tickMs;

      // apply buffered input (prevents instant 180¬∞)
      if (!(nextDir.x === -dir.x && nextDir.y === -dir.y)) dir = nextDir;

      const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };
      // wall collision
      if (head.x < 0 || head.y < 0 || head.x >= canvas.width || head.y >= canvas.height) return gameOver();
      // self collision
      if (snake.some((s,i)=> i>0 && s.x===head.x && s.y===head.y)) return gameOver();

      snake.unshift(head);

      // food eat?
      if (head.x === food.x && head.y === food.y) {
        score++; scoreEl.textContent = String(score);
        // speed up a touch every 5 points (optional)
        if (score % 5 === 0 && tickMs > 50) tickMs = Math.max(50, tickMs - 5);
        food = spawnFood();
      } else {
        snake.pop();
      }
    }

    function drawGrid(){
      // subtle grid (optional): comment out if you prefer solid
      ctx.strokeStyle = '#202733';
      ctx.lineWidth = 1;
      for(let x=GRID; x<canvas.width; x+=GRID){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke(); }
      for(let y=GRID; y<canvas.height; y+=GRID){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke(); }
    }

    function draw() {
      ctx.fillStyle = '#161b22';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // draw grid
      drawGrid();

      // food
      ctx.fillStyle = '#ff6b6b';
      ctx.fillRect(food.x, food.y, GRID, GRID);

      // snake
      ctx.fillStyle = '#00ffff';
      for (const seg of snake) ctx.fillRect(seg.x, seg.y, GRID, GRID);

      // HUD (score text already in DOM, but draw in-canvas too)
      ctx.fillStyle = '#e6edf3';
      ctx.font = '18px Arial';
      ctx.fillText('Score: ' + score, 10, 22);
    }

    function loop(ts) {
      if (!running) return;
      if (paused) { rafId = requestAnimationFrame(loop); return; }
      const dt = ts - lastTs; lastTs = ts;
      update(dt);
      draw();
      rafId = requestAnimationFrame(loop);
    }

    function start(){
      if (running) return;
      running = true; paused = false; lastTs = performance.now();
      rafId = requestAnimationFrame(loop);
      pauseBtn.textContent = '‚è∏Ô∏è Pause';
    }
    function stop(){
      running = false;
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;
    }
    function restart(){
      stop(); initState(); start();
    }

    function togglePause(){
      if (!running) return;
      paused = !paused;
      pauseBtn.textContent = paused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
      showOverlay(paused, 'Paused', 'Press Resume to continue');
      if (!paused) lastTs = performance.now();
    }

    function gameOver(){
      stop();
      // high score
      try {
        const old = Number(localStorage.getItem(HI_KEY) || 0);
        if (score > old) localStorage.setItem(HI_KEY, String(score));
        hiScoreEl.textContent = String(Math.max(score, old));
      } catch {}
      showOverlay(true, 'Game Over', `Score: ${score} ¬∑ High: ${hiScoreEl.textContent}`);
    }

    // Overlay helpers
    function showOverlay(show, title='Game Over', text=''){
      overlay.classList.toggle('show', !!show);
      if (show){ ovTitle.textContent = title; ovText.textContent = text || ovText.textContent; }
    }
    function hideOverlay(){ overlay.classList.remove('show'); }

    // Input helpers
    function setDirection(nx, ny){
      const proposed = {x:nx, y:ny};
      // block 180¬∞ reversals
      if (proposed.x === -dir.x && proposed.y === -dir.y) return;
      nextDir = proposed;
    }

    // Keyboard input
    document.addEventListener('keydown', e=>{
      const k = e.key;
      if (k === 'ArrowUp') setDirection(0,-GRID);
      else if (k === 'ArrowDown') setDirection(0, GRID);
      else if (k === 'ArrowLeft') setDirection(-GRID,0);
      else if (k === 'ArrowRight') setDirection(GRID,0);
      else if (k === 'p' || k === 'P') togglePause();
      else if (k === 'r' || k === 'R') restart();
    });

    // D-pad (Pointer Events ‚Üí works for mouse & touch)
    function bindDir(btn, dx, dy){
      btn.addEventListener('pointerdown', ev => { ev.preventDefault(); setDirection(dx,dy); });
    }
    bindDir(upBtn, 0,-GRID);
    bindDir(downBtn, 0, GRID);
    bindDir(leftBtn,-GRID, 0);
    bindDir(rightBtn,GRID, 0);

    // Buttons
    restartBtn.addEventListener('click', restart);
    pauseBtn.addEventListener('click', togglePause);
    backBtn.addEventListener('click', e=>{
      e.preventDefault();
      if (window.history.length > 1) window.history.back();
      else window.location.href = 'games.html'; // adjust path if nested
    });
    ovRestart.addEventListener('click', restart);
    ovBack.addEventListener('click', ()=> backBtn.click());

    // Speed changes restart (keeps feel consistent)
    speedSel.addEventListener('change', ()=> restart());

    // Auto-pause when tab hidden
    document.addEventListener('visibilitychange', ()=>{ if (document.hidden && running && !paused) togglePause(); });

    // Boot
    initState();
    start();
  </script>
</body>
</html>
